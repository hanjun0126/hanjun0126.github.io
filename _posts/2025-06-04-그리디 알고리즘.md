---
categories: [algorithm, Greedy]
description: 그리디 알고리즘 내용 정리
tags: [이코테 문제]
math: true
---

그리디 알고리즘은 현재 상황에서 가장 좋은 것만을 선택하여 문제를 푸는 방법이다.

## 거스름돈

음식점의 계산을 도와주는 점원이 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구하는 문제이다. 거스름돈으로 사용할 동전은 500원, 100원, 50원, 10원으로 동전은 무한히 존재한다고 가정한다.

점원은 가장 큰 화폐 단위부터 돈을 거슬러 줘야 최소한의 동전 개수를 거슬러 줄 수 있다.

```python
count = 0
coin_types = [500, 100, 50, 10]

n=int(input())

for coin in coin_types:
    count+=n//coin
    n%=coin

print(count)
```

코드를 보면 화폐의 종류만큼 반복을 수행해야 한다. 따라서 화폐의 종류가 K개라고 할 때, 시간 복잡도는 $O(K)$이다. 알고리즘의 시간 복잡도는 동전의 종류에만 영향을 받고, 거슬러 줘야 하는 금액과는 무관하다.

위의 문제를 그리디 알고리즘으로 풀 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이기 때문이다. 만일 500원, 400원, 100원의 동전이 있고 800원을 거슬러 줘야 할 때는, 그리디 알고리즘으로는 4개(500원+100원x3)이지만 최적의 해는 2개(400원x2)이다. 따라서 문제를 그리디 알고리즘으로 풀 수 있는지 검증해야 한다.

## 큰 수의 법칙

큰 수의 법칙이란 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 특징이 있다.

배열 [2, 4, 5, 4, 6]이 있고, M이 8, K가 3으로 주어졌을 때, 큰 수의 법칙을 따른 결과는 6+6+6+5+5+5+6+6+6+5 인 46이 된다. 여기서 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 수라고 간주한다. 배열이 [3, 4, 3, 4, 3], M이 7, K는 2일 때, 큰 수의 법칙을 따른 결과는 4+4+4+4+4+4+4 인 28이다.

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 큰 수의 법칙에 따른 결과를 출력하시오.

입력 조건

1.   첫째 줄에 N($2\le N\le1000$), M($1\le M\le1000$), K($1\le K\le10000$)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
2.   둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10000이하의 수로 주어진다.
3.   입력으로 주어지는 K는 항상 M보다 작거나 같다.

출력 조건

1.   큰 수의 법칙에 따라 더해진 답을 출력한다.

---

### Code

항상 최댓값을 K번 더하고, 다음 수를 더한 후, 다시 최댓값을 더하면 된다.

```python
n, m, k = map(int, input().split())
array = [*map(int, input().split())]

array.sort()
first=array[-1]
second=array[-2]

result = 0
while True:
    for i in range(k):
        if m == 0:
            break
        result += first
        m-=1
    if m==0:
        break
    result += second
    m-=1

print(result)
```

M이 10000 이하이므로 위의 코드로 문제를 해결 할 수 있지만, M의 크기가 100억 이상처럼 커진다면 시간 초과에 걸린다. 즉, 위의 반복문 형태를 수식으로 정리해서 풀면 더 효율적으로 풀 수 있다. M번의 덧셈에서 반복되는 덧셈 연산은 (K+1)번이다. 여기서 K를 곱하면 최대값이 더해지는 횟수가 나온다. M이 K+1로 나누어 떨어지지 않는 경우는 나머지만큼 최댓값을 추가적으로 더해주면 된다.
$$
int(m/(k+1))\times k+m\%(k+1)
$$

```python
n, m, k = map(int, input().split())
array = [*map(int, input().split())]

array.sort()
first=array[-1]
second=array[-2]

count = int(m/(k+1))*k
count += m%(k+1)

result = 0
result += (count)*first
result += (m-count)*second

print(result)
```

## 숫자 카드 게임

숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.

1.   숫자가 쓰인 카드들이 NxM 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다.
2.   먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.
3.   그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.
4.   따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.

입력 조건

1.   첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다. ($1\le N,M\le100$)
2.   둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1이상 10000이하의 자연수이다.

출력 조건

1.   첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.

---

### Code

각 행에서 최솟값을 추출하고, 최솟값들의 최댓값을 출력하면 된다.

```python
n, m = map(int, input().split())
result = 0

for i in range(n):
    array = [*map(int, input().split())]
    min_value = min(array)
    result = max(result, min_value)
print(result)
```

## 1이 될 때까지

어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.

1.   N에서 1을 뺀다.
2.   N을 K로 나눈다.

예를 들어 N이 17, K가 4일 때 1번의 과정을 한 번 수행하면 N은 16이 된다 .이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다. 이는 N을 1로 만드는 최소 횟수이다.

N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성하시오.

입력 조건

1.   첫째 줄에 N($2\le N\le100000$)과 K($2\le K\le100000$)가 공백으로 구분되며 각각 자연수로 주언진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.

출력 조건

1.   첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.

---

### Code

N이 K로 나누어떨어지면 2번의 과정을 아닐 경우 1번의 과정을 반복적으로 수행하면 된다.

```python
n, k = map(int, input().split())
result = 0

while n>=k:
    while n%k!=0:
        n-=1
        result+=1
    n//=k
    result+=1

while n>1:
    n-=1
    result+=1
print(result)
```

반복문을 사용하여 쉽게 풀 수 있지만, 입력 조건 보다 더 큰 범위의 조건이 나온다면 문제를 풀기에는 어려움이 있기에 수학적으로 접근할 수 있어야 한다.

```python
n, k = map(int, input().split())
result = 0
while True:
    target = (n//k)*k
    result += (n-target)
    n = target
    if n<k:
        break
    result+=1
    n//=k
result += (n-1)
print(result)
```

