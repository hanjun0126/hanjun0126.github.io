---
categories: [algorithm, Dynamic Porgramming]
description: 다이나믹 프로그래밍 내용 정리
tags: [algorithm]
math: true
---

이전 두 항의 합을 현재의 항으로 설정하는 피보나치 수열의 점화식은 아래와 같다.
$$
a_n=a_{n-1}+a_{n-2},\ a_1=1,\ a_2=1
$$
이러한 피보나치 수열을 재귀 함수 방식으로 구현할 수 있지만, f(n) 함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문에 효과적인 방법이 아니다. 실제로 재귀 함수로 구현한 코드의 시간 복잡도는 $O(2^N)$으로, 코드가 동작하는데 상당한 시간이 걸린다.

```python
def fibo(x):
	if x==1 or x==2:
        return 1
    return fibo(x-1)+fibo(x-2)
```

## 다이나믹 프로그래밍

이와 같은 상황일 때, **다이나믹 프로그래밍**은 좀 더 좋은 방법이다. 다이나믹 프로그래밍은 다음 두 조건을 만족할 때 사용할 수 있다.

1.   큰 문제를 작은 문제로 나눈ㄹ 수 있다.
2.   작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

다이나믹 프로그래밍에는 재귀 함수처럼 큰 문제를 해결하기 위해 작은 문제를 호출하는 **탑다운 방식**이 있고,  단순히 반복문을 이용하여 작은 문제부터 답을 도출하여 문제를 푸는 **보텀업 방식**이 있다.

### 메모이제이션(Memoization) - 탑다운&하향식

피보나치 수열은 이러한 조건을 만족하는 문제이고, 이 문제를 **메모이제이션** 기법을 사용해서 해결할 것이다. 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, **한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법**이다. 메모이제이션은 값을 저장하는 방법이므로 캐싱(Caching)이라고도 한다. 메모이제이션은 한 번 구한 정보를 리스트에 저장한다. 그 후, 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요한 때는 이미 구한 정답을 그대로 리스트에서 가져온다. 이렇게 했을 때 시간 복잡도는 $O(N)$이게 된다.

```python
dp=[0]*100

def fibo(x):
    if x==1 or x==2:
        return 1
    
    if dp[x]!=0:
        return dp[x]
    
    dp[x] = fibo(x-1)+fibo(x-2)
    
    return dp[x]
```

이처럼 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다. 

### 보텀업&상향식

**다이나믹 프로그래밍을 재귀 함수를 사용하여 풀 때, 결국 함수를 다시 호출하게 되는 과정을 거치게 된다.** 즉 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로 **오버헤드**(어떤 처리를 하기 위해 들어가는 간접적인 처리 시간$\cdot$메모리 등)가 발생할 수 있다. 따라서 재귀 함수 대신에 반복문을 사용하여 오버헤드를 줄일 수 있다. 일반적으로 반복문을 이용한 다이나믹 프로그래밍이 더 성능이 좋다.

```python
dp=[0]*100
dp[1], dp[2] = 1, 1

for i in range(3, 100):
    dp[i] = dp[i-1] + dp[i-2]
```

---

"이것이 취업을 위한 코딩 테스트다 with 파이썬" 실전 문제

### P1. 1로 만들기

입력 조건 : 첫째 줄에 정수 x가 주어진다.($1\le x\le30000$)

출력 조건 : 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

정수 x가 주어질 때 정수 x에 사용할 수 있는 연산은 다음과 같이 4가지이다.

1.   x가 5로 나누어떨어지면, 5로 나눈다.
2.   x가 3로 나누어떨어지면, 3로 나눈다.
3.   x가 2로 나누어떨어지면, 2로 나눈다.
4.   x에서 1을 뺀다.

정수 x가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 할 때, 연산을 사용하는 횟수의 최솟값을 출력하시오.

---

문제에서 구하는 현재 x의 연산 횟수를 구하는 방법을 생각하면 4가지이다. x이전 까지의 최솟값들이 다 구해져 있고, 이들이 dp테이블에 있다고 가정하자. 그렇다면 x를 구할 수 있는 방법의 횟수는 다음과 같다.

1.   dp[x/5] + 1
2.   dp[x/3] + 1
3.   dp[x/2] + 1
4.   dp[x-1] + 1

즉, 이 4개의 값중에서 최솟값을 구하는 문제이므로, 점화식은 $a_i=min(a_{i-1},a_{i/2},a_{i/3},a_{i-5})+1$ 이다.

#### Code

```python
x = int(input())
dp = [0]*30001

for i in range(2, x+1):
    dp[i] = dp[i-1] + 1
    if i%2==0:
    	dp[i] = min(dp[i], dp[i//2] + 1)
    if i%3==0:
    	dp[i] = min(dp[i], dp[i//3] + 1)
    if i%5==0:
    	dp[i] = min(dp[i], dp[i//5] + 1)
        
print(dp[x])
```

---

### P2. 개미 전사

입력 조건

1.   첫째 줄에 식량창고의 개수 N이 주어진다.($3\le N\le100$)
2.   둘째 줄에 공백으로 구분되어 각 식량창고에 저장된 식량의 개수 K가 주어진다.

출력 조건 : 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하시오.

개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 개미 전사가 일직선 상 각각의 식량창고를 털 때마다, 메뚜기 정찰병들은 서로 인접한 식량창고가 공격받았는지 알 수 있다. 개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최대값을 구하는 프로그램을 작성하시오.

---

일직선 상의 있는 식량창고를 털때 서로 인접한 식량창고에서는 공격받았는지 알 수 있으므로, n번째 식량창고를 털면 n-1, n+1번째 식량창고는 털 수 없다. 따라서 이를 점화식으로 표현하면 다음과 같다.
$$
dp[i] = max(dp[i-1], dp[i-2]+a[i])
$$
현재 시점에서만 본다면, i번째 식량창고에서 얻을 수 있는 식량 획득 방법은 두 가지이다.

1.   현재 식량창고를 털지 않고, 이전의 식량창고를 털었을 때 얻은 최대 식량.
2.   현재 식량창고를 털었기에, 이전의 식량창고는 털지 못하였고, 전전의 식량창고를 털었을 때 얻은 최대 식량과 현재 식량창고의 식량의 합.

#### Code

```python
n = int(input())
array = list(map(int, input().split()))

dp = [0]*100

dp[0] = array[0]
dp[1] = max(array[0], array[1])

for i in range(2, n):
    dp[i] = max(dp[i-1], dp[i-2] + array[i])
    
print(dp[n-1])
```

---

### P3. 바닥 공사

가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다. 태일이는 이 얇은 바닥을 1x2, 2x1, 2x2 크기의 덮개를 이용해 채우고자 한다. 이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오

입력 조건 : 첫째 줄에 N이 주어진다. $1\le N\le1000$

출력 조건 : 첫째 줄에 2xN 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다.

---

<img src="../assets/img/알고리즘/바닥 타일.png" alt="바닥 타일" style="zoom:40%;" />

N이 3일 때, 경우의 수는 5가지이다. 이는 이전 단계까지 타일이 채워진 곳에 1x2 크기의 타일을 채우는 경우와 두 단계 전까지 타일이 채워진 곳에 2x1을타일 2개를 까는 경우와 2x2 타일을 까는 경우의 총합이다. 따라서 점화식은 다음과 같다.
$$
dp[i] = dp[i-2]*2+dp[i-1]
$$

#### Code

```python
n = int(input())

dp = [0]*100

dp[1] = 1
dp[2] = 3

for i in range(3, n+1):
    dp[i] = (dp[i-1] + 2*dp[i-2])%796796
    
print(dp[n])
```

---

### P4. 효율적인 화폐 구성

N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.

입력 조건

1.   첫째 줄에 N, M이 주어진다.($1\le N\le100,\ 1\le M\le10000$)
2.   이후 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐 가치는 10000보다 작거나 같은 자연수이다.

출력 조건

1.   첫째 줄에 M원을 만들기 위한 최소한의 화폐 개수를 출력한다.
2.   불가능할 때는 -1을 출력한다.

---

화폐 가치 M이 되도록 하기 위해서 N가지 종류의 화폐를 사용한다. 작은 단위의 화폐부터 시작해서 큰 단위의 화폐를 만들 수 있는 방법을 확인하여 문제를 풀 수 있다. 화폐 가치 0~M까지의 dp테이블에서 각각의 화폐로 만들 수 있으면 테이블을 갱신해주면 된다. 점화식은 아래와 같다.
$$
dp[j] = min(dp[j], dp[j-array[i]]+1)
$$
dp테이블은 처음에 10001로 초기화 하였다. 이는 1원이라는 화폐가 나오는 경우에도 M의 최댓값이 10000원을 만들기 위해서 10000개를 써야 하므로, 최소한의 화폐 개수를 갱신해주기 위해서 10001로 초기화 해줬다. 즉, dp테이블을 1원부터 시작해서, M원까지 계속해서 갱신해줄 것이다. 이 과정을 화폐 종류만큼 반복하게 된다.

<img src="../assets/img/알고리즘/화폐 단위.png" alt="화폐 단위" style="zoom:30%;" />

N=2, 3, 5이고 M=7일 때, 0부터 7까지의 dp테이블을 갱신해주는 작업을 하게 된다. 처음에는 dp[0]=0을 제외한 모든 테이블이 10001로 초기화 되어있다. 2원으로 만들 수 있는 경우부터 시작해서 dp[i-2]가 10001인 경우는 2원을 사용해서 dp[i]를 만들 수 없는 경우이고, dp[i-2]가 10001이 아닌 경우는 이전까지 화폐 가치 i-2원을 만들었다는 의미이기에, 2원을 추가함으로써 dp[i-2]+1개의 화폐 개수로 화폐 가치 i원을 만들 수 있게 된다. 이처럼 다른 화폐에 대해서도 해주게 된다면, 최종적으로 M원을 만들때 필요한 최소한의 화폐 갯수를 구할 수 있다.

#### Code

```python
n, m = map(int, input().split())
array = []
for i in range(n):
    array.append(int(input()))
    
dp = [10001]*(m+1)

dp[0] = 0
for i in range(n):
    for j in range(array[i], m+1):
        if dp[j-array[i]] != 10001:
            dp[j] = min(dp[j], dp[j-array[i]] + 1)

if dp[m] == 10001:
    print(-1)
else:
    print(dp[m])
```

